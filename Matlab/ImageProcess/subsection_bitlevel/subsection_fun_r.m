%----------------分段线性变换-----------------
%----------------分段不连续的情况--------------
%	+
%  / \
%	|                    .
%	|                  .  恒等线
%	|                .
%	|              .
%	|            .
%	|          .
%	|        . |
%	|      .   |
%	|    .-----|
%	|  .
%	|------------------------->
%        x11   x22
%	这样的话，可以随意的改变某个亮度范围内的像素点的表现形式，
%	比如，我现在想完全抑制亮度值位于0～50之间的像素点，也就是让他变成0
%	则，我们这样设置X，Y， X = [ 0 50 ]; Y = [ 0 0 ];
%	同样的，完全增强200～250之间的值，则X = [ 200 250 ]; Y = [ 255 255 ];
%
%	此函数的功能不止如此，还有其他很多作用，比如实现 （P69作业--冈萨雷斯--数字图像处理（第二版））
%	很方便，只需令 X = [ 0 127 ; 129 255 ]; Y = [ 0 0 ; 255 255 ];
%	同样的方法抽取其他位平面一样方便
%
%
function resultimage = subsection_fun_r( image, X, Y )

	%计算K, 可以和下面生成曲线一起运算，提高效率，但为了可读性，采用这种方式
	K = cal_slopt(X,Y);

	%生成曲线
	%此部分将subsection_fun.m

	%处理图像,
	imtmp = double(image);
	n = size(K,2);
	i = 1;
	while i < n + 1
		%这里开闭其实没什么影响，只是在提取第0位平面是需要闭合，建议闭合
		%index = find( ( imtmp>X(i,1) ).*( imtmp<X(i,2) ));
		index = find( ( imtmp >= X(i,1) ).*( imtmp <= X(i,2) ));
		imtmp(index) = K(i)*imtmp(index) - K(i)*X(i,1) + Y(i,1);
		i = i + 1;
	end;

	resultimage = uint8(imtmp);

end

function K = cal_slopt( X , Y )
	%获取点数 = 分段数 + 1
	num = size(X,1);
	K = zeros(1,num-1);
	i = 1;
	while i < num + 1
		if X(i,2) ~= X(i,1)
			K(i) = ( Y(i,2)-Y(i,1) ) / ( X(i,2) - X(i,1) );
		else 	%切记考虑这种情形
			K(i) = 0;
		end;
		i = i + 1;
	end;
end

